<!doctype html>
<html lang="en" ng-app="avlApp">
<head>
<meta charset="utf-8"/>
<title>AVL Tree Simulator</title>
<style>
  body { font-family: Arial, sans-serif; margin: 0px; background: #15c26b; color: #111827; }
  h1 { font-size: 30px; margin-top: 0px; margin-bottom: 0px; }
  .controls { display: flex; gap: 8px; flex-direction: column; flex-wrap: wrap; margin-bottom: 14px; margin-left: 10px;}
  input[type="number"], input[type="text"] { padding: 15px 10px; border-radius: 6px; border: 1px solid #d1d5db; width: 70%; }
  button { padding: 8px 12px; border-radius: 6px; border: none; cursor: pointer; background: #25eb88; color: white; font-weight: 600; }
  button.secondary { background: #dc2626; }
  button.warn { background: #25eb88; }
  button.undo { background: #25eb88; }
  button.redo { background: #25eb88; }
  .main-container { display: flex; gap: 12px; }
  #canvasWrap { background: white; border-radius: 8px; padding: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); height: 594px; width: 1000px; overflow: auto; }
  .output-container { width: 300px; display: flex; flex-direction: column; gap: 8px; }

  svg { width: 100%; height: 99%; }
  .edge { stroke: #9ca3af; stroke-width: 2px; }
  .node circle { fill: white; stroke: #1e293b; stroke-width: 2px; transition: 0.3s; }
  .node text { font-weight: bold; font-size: 12px; text-anchor: middle; dominant-baseline: middle; }
  .highlight circle { fill: #fde68a; stroke: #b45309; }
  .rotation circle { fill: #dbeafe; stroke: #1e3a8a; }
  .log { background: #0f172a; color: #f1f5f9; font-family: monospace; padding: 8px; height: 598px; width: 445px; overflow-y: auto; border-radius: 6px; font-size: 13px; }
  .status { padding: 6px 10px; border-radius: 6px; font-weight: 650; text-align: center; }
  .status.ok { background-color: #25eb88; color: white; }
  .status.warn { background-color: #dc2626; color: white; }

  .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 9999; }
  .overlay-content { background: white; padding: 20px 30px; border-radius: 10px; width: 50%; max-width: 600px; text-align: left; position: relative; z-index: 10000; }
  .close-btn { position: absolute; top: 10px; right: 15px; background-color: #b40909; color: #fff; border: none; font-size: 24px; cursor: pointer; z-index: 10001; }
  .close-btn:hover { background-color: red; color: #fff; }
.rotation-alert-overlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(0,0,0,0.3);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10000;
}

.rotation-alert-content {
  background: #fff9c4;
  padding: 20px 30px;
  border-radius: 10px;
  text-align: center;
  width: 300px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.rotation-alert-content h3 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 18px;
}

.close-rotation-alert {
  padding: 6px 12px;
  margin-top: 12px;
  border-radius: 6px;
  border: none;
  cursor: pointer;
  background: #25eb88;
  color: #fff;
  font-weight: 600;
}
</style>
</head>
<body ng-controller="AvlCtrl as vm">
<h1 style="background-color: #15c26b; color: #fff; padding: 15px;">
  <input type="number" ng-model="vm.inputValue" placeholder="Enter value">
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  AVL Tree Simulator
  &nbsp; &nbsp; 
</h1>
<div class="status" ng-class="{'ok': vm.isBalanced, 'warn': !vm.isBalanced}">
  {{vm.isBalanced ? 'Tree is Balanced' : 'Tree is NOT Balanced'}} - Balance Factor: {{vm.balanceFactor}}
</div>
<div ng-show="vm.showAbout" class="overlay">
  <div class="overlay-content">
    <h2>About AVL Tree Simulator
      <button class="close-btn" ng-click="vm.showAbout = false">&times;</button>
    </h2>
    <p>
    * Self-balancing Binary Search Tree (BST) where the heights of left and right subtrees almost equal. <br> 
    * A simple representation of this tree is, <br> 
    <br><br> 
    <pre> 
       N (Node)               N (Node)                  N (Node) 
      / \           or        /               or          \      
    L     R                 L                             R
    </pre> 
    * After the insertion, the balance factor of each node is checked during the path back up to the root. <br> 
    * If any node becomes unbalanced (i.e., its balance factor becomes less than -1 or greater than +1), a rotation is required to restore the AVL property. <br> 
    * In an AVL Tree, rotations are used to maintain balance after insertion or deletion of nodes. <br> 
    * The balance factor must be between -1 and 1 for all nodes. <br> 
</p>
    </p>
  </div>
</div>
<div class="main-container">
<div class="controls">
  <br><br><br>
  <button ng-click="vm.insert()">Insert</button>
  <button class="secondary" ng-click="vm.remove()">Delete</button>
  <button ng-click="vm.balanceTree()">Balance</button>
  <button class="warn" ng-click="vm.clear()">Clear</button>
  <button class="undo" ng-click="vm.undo()">Undo</button>
  <button class="redo" ng-click="vm.redo()">Redo</button>
  <button ng-click="vm.showAbout = true">About</button>
</div>

<div id="canvasWrap">
  <svg>
    <g ng-repeat="edge in vm.edges">
      <line class="edge" ng-attr-x1="{{edge.x1}}" ng-attr-y1="{{edge.y1}}" ng-attr-x2="{{edge.x2}}" ng-attr-y2="{{edge.y2}}"></line>
    </g>
    <g ng-repeat="node in vm.nodes" class="node" ng-class="{'highlight': node.highlight, 'rotation': node.rotation}" ng-attr-transform="translate({{node.x}},{{node.y}})">
      <circle r="18"></circle>
      <text>{{node.value}}</text>
    </g>
  </svg>
</div>
<div class="log">
  <div ng-repeat="line in vm.log track by $index">{{::$index + 1}}. {{line}}</div>
</div>
</div>
<div class="rotation-alert-overlay" ng-show="vm.showRotationAlert">
  <div class="rotation-alert-content">
    <h3>Rotation Alert</h3>
    <p>{{vm.rotationMessage}}</p>
    <button class="close-rotation-alert" ng-click="vm.closeRotationAlert()">OK</button>
  </div>
</div>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.3/angular.min.js"></script>
<script>
angular.module('avlApp', [])
.controller('AvlCtrl', ['$scope', function($scope){
  const vm = this;
  vm.root = null;
  vm.nodes = [];
  vm.edges = [];
  vm.log = [];
  vm.isBalanced = true;

  vm.undoStack = [];
  vm.redoStack = [];

  function Node(val){ this.value = val; this.left = null; this.right = null; this.height = 1; }
  function h(n){ return n ? n.height : 0; }
  function upd(n){ n.height = 1 + Math.max(h(n.left), h(n.right)); }
  function bal(n){ return n ? h(n.left) - h(n.right) : 0; }

  function cloneTree(node){
    if(!node) return null;
    const n = new Node(node.value);
    n.left = cloneTree(node.left);
    n.right = cloneTree(node.right);
    n.height = node.height;
    return n;
  }

  function rightRotate(y){
    const x = y.left; const T2 = x.right;
    x.right = y; y.left = T2;
    upd(y); upd(x);
    vm._log('Right rotation on ' + y.value);
    return x;
  }

  function leftRotate(x){
    const y = x.right; const T2 = y.left;
    y.left = x; x.right = T2;
    upd(x); upd(y);
    vm._log('Left rotation on ' + x.value);
    return y;
  }

  function insertNode(root, key){
    if(!root) return new Node(key);
    if(key < root.value) root.left = insertNode(root.left, key);
    else if(key > root.value) root.right = insertNode(root.right, key);
    else return root; 
    upd(root);
    return root;
  }

  function minNode(n){ while(n.left) n = n.left; return n; }
  function deleteNode(root, key){
    if(!root) return root;
    if(key < root.value) root.left = deleteNode(root.left, key);
    else if(key > root.value) root.right = deleteNode(root.right, key);
    else {
      if(!root.left) return root.right;
      if(!root.right) return root.left;
      const t = minNode(root.right);
      root.value = t.value;
      root.right = deleteNode(root.right, t.value);
    }
    upd(root);
    return root;
  }

  function saveState(){ vm.undoStack.push(cloneTree(vm.root)); vm.redoStack = []; }

  vm.insert = function(){
    const v = Number(vm.inputValue);
    if(isNaN(v)){ vm._log('Invalid input'); return; }
    saveState();
    vm.root = insertNode(vm.root, v);
    vm._log('Inserted ' + v);
    vm.update();
  };

  vm.remove = function(){
    const v = Number(vm.inputValue);
    if(isNaN(v)){ vm._log('Invalid input'); return; }
    saveState();
    vm.root = deleteNode(vm.root, v);
    vm._log('Deleted ' + v);
    vm.update();
  };

  vm.clear = function(){
    saveState();
    vm.root = null; vm.nodes=[]; vm.edges=[];
    vm._log('Tree cleared');
    vm.update();
  };

  vm.undo = function(){
    if(vm.undoStack.length===0){ vm._log('Nothing to undo'); return; }
    vm.redoStack.push(cloneTree(vm.root));
    vm.root = vm.undoStack.pop();
    vm._log('Undo performed');
    vm.update();
  };

  vm.redo = function(){
    if(vm.redoStack.length===0){ vm._log('Nothing to redo'); return; }
    vm.undoStack.push(cloneTree(vm.root));
    vm.root = vm.redoStack.pop();
    vm._log('Redo performed');
    vm.update();
  };

function balanceNodeAnimated(root) {
  if (!root) return Promise.resolve(null);

  return balanceNodeAnimated(root.left).then(newLeft => {
    root.left = newLeft;
    return balanceNodeAnimated(root.right);
  }).then(newRight => {
    root.right = newRight;
    upd(root);
    const b = bal(root);

    let rotated = null;
    let rotationType = '';

    if (b > 1 && bal(root.left) >= 0) {
      rotated = rightRotate(root);
      rotationType = 'Right Rotation';
    }
    else if (b > 1 && bal(root.left) < 0) {
      root.left = leftRotate(root.left);
      rotated = rightRotate(root);
      rotationType = 'Left-Right Rotation';
    }
    else if (b < -1 && bal(root.right) <= 0) {
      rotated = leftRotate(root);
      rotationType = 'Left Rotation';
    }
    else if (b < -1 && bal(root.right) > 0) {
      root.right = rightRotate(root.right);
      rotated = leftRotate(root);
      rotationType = 'Right-Left Rotation';
    }

    if (rotated && rotationType !== '') {
      vm.rotationMessage = rotationType;
      vm.showRotationAlert = true;
      vm.update();

      rotated.rotation = true;
      return new Promise(resolve => {
        setTimeout(() => {
          rotated.rotation = false;
          vm.update();
          resolve(rotated);
        }, 600); 
      });
    }

    return root;
  });
}

vm.balanceTree = function(){
  saveState();
  balanceNodeAnimated(vm.root).then(newRoot => {
    vm.root = newRoot;
    vm._log('Tree balanced with animation');
    vm.update();
  });
};

  function checkBalance(root){
    if(!root) return true;
    const b = bal(root);
    if(b<-1 || b>1) return false;
    return checkBalance(root.left) && checkBalance(root.right);
  }

  vm._log = function(msg){
    vm.log.push('['+new Date().toLocaleTimeString()+'] '+msg);
    if(vm.log.length>200) vm.log.shift();
    if(!$scope.$$phase) $scope.$applyAsync();
  };

  vm.update = function(){
    vm.nodes=[]; vm.edges=[];
    let xIndex = 0; const levelH = 80, spacingX = 50;

    function inorder(n, depth){
      if(!n) return;
      inorder(n.left, depth+1);
      const x = xIndex++*spacingX+40;
      const y = depth*levelH+30;
      vm.nodes.push({value:n.value, x:x, y:y});
      inorder(n.right, depth+1);
    }
    inorder(vm.root,0);

    function find(v){ return vm.nodes.find(n=>n.value===v); }
    function connect(n){
      if(!n) return;
      if(n.left) vm.edges.push({x1:find(n.value).x, y1:find(n.value).y+18, x2:find(n.left.value).x, y2:find(n.left.value).y-18});
      if(n.right) vm.edges.push({x1:find(n.value).x, y1:find(n.value).y+18, x2:find(n.right.value).x, y2:find(n.right.value).y-18});
      connect(n.left); connect(n.right);
    }
    connect(vm.root);

    vm.isBalanced = checkBalance(vm.root);
    vm.balanceFactor = vm.root ? (h(vm.root.left) - h(vm.root.right)) : 0;
  };

  vm.showAbout = false;

vm.showRotationAlert = false;
vm.rotationMessage = '';

vm.closeRotationAlert = function() {
  vm.showRotationAlert = false;
  $scope.$applyAsync();
};

}]);
</script>
</body>
</html>
